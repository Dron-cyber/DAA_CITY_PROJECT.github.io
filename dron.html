<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Case Studies – City Design Project</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="style.css">
</head>

<body>

<div class="side-menu" id="sideMenu">
    <ul>
        <li><a href="index.html" onclick="closeMenu()">Home</a></li>
        <li><a href="project.html" onclick="closeMenu()">Project</a></li>
        <li><a href="dron.html" onclick="closeMenu()">Dron</a></li>
        <li><a href="sunil.html" onclick="closeMenu()">Sunil</a></li>
        <li><a href="darshan.html" onclick="closeMenu()">Darshan</a></li>
    </ul>
</div>

<nav class="navbar">
    <h2>Case Studies</h2>
    <div class="hamburger" onclick="openMenu()">
        <span></span>
        <span></span>
        <span></span>
    </div>
    <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="project.html">Project</a></li>
        <li><a href="dron.html">Dron</a></li>
        <li><a href="sunil.html">Sunil</a></li>
        <li><a href="darshan.html">Darshan</a></li>
    </ul>
</nav>

<section id="case-studies">
    <h1>Algorithm-Driven Urban Solutions</h1>
    <p style="text-align:center; font-size:18px;">
        Applying core Design and Analysis of Algorithms (DAA) concepts to solve real-world city design challenges.
    </p>

    <div class="case-study-grid" id="caseStudyGrid">
    </div>
    
    <div class="explanation-section">
        <h3>Core Design, Principles, and Data Structures Used</h3>
        <p>This project utilizes a range of advanced algorithmic techniques to ensure high efficiency and scalability across all urban solutions.</p>
        <ul>
            <li><strong>Design Techniques Used:</strong> We rely heavily on the Greedy Technique (for optimal selections in Kruskal's and Dijkstra's), Divide and Conquer (for tree-based structures like Segment/Fenwick Trees), and the crucial Space and Time Trade-off (using specialized data structures to minimize time complexity at the cost of slightly more memory).</li>
            <li><strong>Core Principles Applied:</strong> The project extensively uses principles such as Connectivity and Reachability (Graph Traversal), Edge Relaxation (Dijkstra's), Pre-Computing (Segment/Fenwick Trees), the Cut and Cycle Properties (Kruskal's), Bit Manipulations (Fenwick Tree), and Balance Maintenance (Heaps). We also leverage Recursion in tree traversals and Search Space Exploration in graph algorithms.</li>
            <li><strong>Data Structures Employed:</strong> Solutions rely on Heap/Priority Queue for instant min/max retrieval, Trie for fast string prefix searching, Segment Tree and Fenwick Tree for O(\log n) range queries/updates, and Union-Find (Disjoint Set Union) for cycle detection.</li>
            <li><strong>SDG Mapping:</strong> This work directly supports SDG 9 (Infrastructure) and SDG 11 (Sustainable Cities).</li>
        </ul>
    </div>
</section>

<div class="modal-overlay" id="modalOverlay" onclick="closeModal(event)">
    <div class="modal-content" id="modalContent">
    </div>
</div>
<script>

function openMenu() {
    document.getElementById("sideMenu").classList.add("active");
}
function closeMenu() {
    document.getElementById("sideMenu").classList.remove("active");
}
document.addEventListener('click', function(event) {
    const sideMenu = document.getElementById('sideMenu');
    const hamburger = document.querySelector('.hamburger');
    if (!sideMenu.contains(event.target) && !hamburger.contains(event.target) && sideMenu.classList.contains('active')) {
        closeMenu();
    }
});



const caseStudies = [
    {
        id: 'c1',
        title: 'Optimal Routes for City Transport',
        problem: 'Efficiently find the shortest/fastest route between any two points in the city’s road network.',
        icon: 'fa-route',
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c1',
        algo: 'Dijkstra’s Algorithm',
        diagram: `<img src="./dron_img/c1.png" style="max-width:100%; height:500px;">`,
        why: 'Dijkstra\'s is used because the road network can be modeled as a weighted graph where edge weights (time/distance) are non-negative. It guarantees the globally shortest path by employing the <strong>Greedy Technique</strong>—always selecting the closest unvisited node—and the <strong>Edge Relaxation</strong> principle to constantly update and improve path distances.',
        how: [
            'Treat every junction as a node and road as an edge with weight (cost).',
            'Initialize distances and use a Min-Heap (Priority Queue) to always select the unvisited node with the smallest distance.',
            'Apply Edge Relaxation: Check neighbors to see if a shorter path exists through the current node; if so, update the neighbor\'s distance.',
            'Continue until the destination is reached, building the Shortest Path Tree.'
        ],
        complexityCode: `
Time Complexity Derivation (Using Binary Min-Heap):

Assumptions:
V = Number of Vertices (Junctions)
E = Number of Edges (Roads)
The algorithm iterates V times (once per vertex) and checks E edges (once per edge).

Step 1: Initialization and First Insertions
- Initializing distances and adding all V vertices to the Priority Queue.
- Cost: O(V) (for initialization) + O(V log V) (for V insertions)
- Total: O(V log V)

Step 2: V Extractions (Main Loop)
- The loop runs V times, and in each iteration, the minimum distance vertex is extracted from the Min-Heap.
- Cost per Extract Min: O(log V)
- Total Cost: V * O(log V) = O(V log V)

Step 3: E Edge Relaxations (Inner Loop)
- Every edge E is processed once. Checking an edge might lead to a "Decrease Key" operation (updating a neighbor's distance in the heap).
- Cost per Decrease Key: O(log V)
- Total Cost: E * O(log V) = O(E log V)

Overall Time Complexity:
Sum of all steps: O(V log V) + O(V log V) + O(E log V)
Simplifying: O(2V log V + E log V)
Factoring out log V and dropping the constant:
O((V + E) log V)
`,
        complexity: 'O((V + E) log V)'
    },
    {
        id: 'c2',
        title: 'Airport Flight Gate Assignment',
        problem: 'Assign gates to arriving/departing flights to maximize gate use and ensure no schedule overlaps.',
        icon: 'fa-plane-departure', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c2',
        algo: 'Min-Heap + Sorting',
        diagram: `<img src="./dron_img/c2.png" style="max-width:100%; height:500px;">`,
        why: 'This is a <strong>Greedy Technique</strong> interval scheduling problem. Sorting the flights by arrival time ensures chronological processing. The <strong>Min-Heap</strong> is used to store gate release times, allowing instant access (O(\log k)) to the earliest available gate. This decision-making process minimizes the total number of gates required.',
        how: [
            'Flights are first sorted by arrival time.',
            'A Min-Heap maintains the departure/release times of all currently occupied gates.',
            'For each flight: If the heap\'s minimum element (earliest free gate time) is less than or equal to the flight\'s arrival time, that gate is reused (pop and push new departure time).',
            'Otherwise, a new gate is assigned (push the new departure time).'
        ],
        complexityCode: `
Time Complexity Derivation (Using Sorting + Binary Min-Heap):

Assumptions:
N = Total Number of Flights
K = Maximum Number of Gates needed (K <= N)

Step 1: Initial Sorting of Flights
- Purpose: Sort all N flights by their arrival time to enable chronological, greedy processing.
- Cost: N * O(log N) = O(N log N)

Step 2: Processing Flights and Heap Operations (The Main Loop)
- Purpose: Iterate through the sorted flights, using the Min-Heap (size K) to track the earliest available gate time.
- Operations: Each of the N flights results in one Extract Min and one Insert/Update operation on the heap.
- Cost per operation: O(log K)
- Total Cost: N * O(log K) = O(N log K)

Overall Time Complexity:
Sum of all steps: (Step 1) + (Step 2)
Total Time Complexity = O(N log N) + O(N log K) 

Since K <= N, the term O(N log N) (from the initial sorting) dominates the total cost.

Final Time Complexity = **O(N log N)** `,
        complexity: 'O(N log N)'
    },
    {
        id: 'c3',
        title: 'Land Allotment Query System',
        problem: 'Manage city land plots requiring fast range-based queries (e.g., free plots between X and Y) and dynamic updates (land allocation/release).',
        icon: 'fa-map-marked-alt', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c3',
        algo: 'Segment Tree',
        diagram: `<img src="./dron_img/c3.png" style="max-width:100%; height:500px;">`,
        why: 'The <strong>Segment Tree</strong> is an application of the <strong>Divide and Conquer</strong> and <strong>Space and Time Trade-off</strong> principles. It allows both updates (Point Updates) and range queries (Range Aggregate Queries) to be completed in O(log n) time, providing quick and dynamic responsiveness for city planners over static array-based systems.',
        how: [
            'The land plots are modeled as an array, over which the Segment Tree is built hierarchically.',
            'Each node stores an aggregated value (e.g., total occupied land) for its specific range of plots.',
            'Updates (allocating/releasing a plot) traverse one path from the leaf to the root, taking $O(\log n)$ time.',
            'Queries efficiently combine the aggregated data from relevant nodes to cover the requested range, also taking $O(\log n)$ time.'
        ],
        complexityCode: `
Time Complexity Derivation (Segment Tree):

Assumptions:
N = Number of elements in the base array (Land Plots)
The Segment Tree is a balanced binary tree built over the array.

Step 1: Tree Construction (Preprocessing)
- Purpose: Build the Segment Tree structure from the base array.
- Operation: Traversing the array and recursively building the tree.
- Cost: Since the tree has O(N) nodes and each node is processed once (summing its children), the construction time is linear.
- Total Cost: O(N)

Step 2: Point Update (Land Allocation/Release)
- Purpose: Change the value of a single element in the base array and update the aggregated values in the tree.
- Operation: The update only needs to traverse a single path from the leaf node (the plot) up to the root.
- Cost per traversal: The height of the balanced binary tree is O(log N).
- Total Cost: O(log N)

Step 3: Range Query (Finding total occupied space in a zone [i, j])
- Purpose: Query the aggregated value over a specified range [i, j].
- Operation: The query traverses the tree, breaking the range into O(log N) canonical segments (tree nodes) that cover the range exactly.
- Cost per query: The number of nodes accessed is bounded by O(log N) on the left side and O(log N) on the right side of the tree.
- Total Cost: O(log N)

Final Time Complexity:
The two most critical operations (Update and Query) are both logarithmic.

Final Time Complexity = O(log N) for updates and queries.
`,
        complexity: 'O(log N)'
    },
    {
        id: 'c4',
        title: 'Crime Hotspot Detection',
        problem: 'Identify and rank clusters of high-crime areas to efficiently deploy police and resources.',
        icon: 'fa-shield-alt', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c4',
        algo: 'DFS / BFS + Max-Heap',
        diagram: `<img src="./dron_img/c4.png" style="max-width:100%; height:500px;">`,
        why: 'This solution uses <strong>DFS/BFS</strong> to explore <strong>Connectivity</strong> and identify distinct clusters (connected components) of high-crime areas on the city grid. The <strong>Max-Heap (Priority Queue)</strong> then ranks these clusters by severity (a <strong>Greedy Technique</strong> for prioritization), ensuring resources are first deployed to the most critical zones.',
        how: [
            'The city is mapped onto a grid. Iterate through each cell/area.',
            'If a cell exceeds the crime threshold, initiate a DFS or BFS to find all connected adjacent cells that also exceed the threshold, marking them as visited.',
            'The search calculates the total size or severity score of the connected cluster.',
            'This score is pushed into a Max-Heap, which can instantly retrieve the largest/most severe hotspot.'
        ],
        complexityCode: `
Time Complexity Derivation (DFS/BFS + Max-Heap):

Assumptions:
R = Rows of the city grid
C = Columns of the city grid
V (Vertices) = R * C (Total number of cells/areas)
E (Edges) = O(R * C) (Number of connections between cells)
H = Total number of distinct Hotspot Clusters found
K = Number of Top Hotspots to retrieve (Size of the Max-Heap, usually a small constant like 10)

Step 1: Grid Traversal and Cluster Identification
- Purpose: Iterate through every cell (vertex) on the grid and use Depth-First Search (DFS) or Breadth-First Search (BFS) to identify all connected components (clusters) that exceed the crime threshold.
- Operation: Since every cell/vertex is visited at most once, and every link/edge is checked at most once, the time complexity for graph traversal is proportional to V + E.
- Total Cost: O(V + E) = O(R * C)

Step 2: Ranking Hotspots (Max-Heap Operations)
- Purpose: Insert the size/severity score of each of the H identified clusters into a Max-Heap to prioritize the largest/most critical ones.
- Operation: H insertions/updates into a heap of size K.
- Cost per operation: O(log K)
- Total Cost: H * O(log K) = O(H log K)

Overall Time Complexity:
The overall time is the sum of the cluster finding (Step 1) and the ranking (Step 2).

Total Time Complexity = O(R * C) + O(H log K)

Final Time Complexity = O(R * C + H log K)
`,
        complexity: 'O(R*C + H log K)'
    },
    {
        id: 'c5',
        title: 'Road Building Cost Minimization',
        problem: 'Design a new road network that connects all major city areas with the absolute minimum total construction cost.',
        icon: 'fa-hard-hat', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c5',
        algo: 'Kruskal’s MST Algorithm',
        diagram: `<img src="./dron_img/c5.png" style="max-width:100%; height:500px;">`,
        why: 'The problem is solved using the Minimum Spanning Tree (MST) concept. Kruskal\'s algorithm is a <strong>Greedy Technique</strong>: it sorts all potential roads by cost and uses the <strong>Union-Find</strong> data structure to check <strong>Connectivity</strong> and efficiently apply the <strong>Cut and Cycle Properties</strong>, guaranteeing the minimum overall construction cost.',
        how: [
            'Treat city areas as nodes (V) and potential roads as edges (E) with cost as the weight.',
            'Sort all edges by cost (ascending).',
            'Initialize the Union-Find (Disjoint Set Union) structure where each area is its own set.',
            'Iterate through the sorted edges: Add an edge to the MST only if its two endpoints belong to different sets (i.e., it doesn\'t form a cycle).',
            'Perform the union operation to merge the sets of the two connected areas. Stop when V-1 edges are included.'
        ],
        complexityCode: `
Time Complexity Derivation (Kruskal's MST Algorithm):

Assumptions:
V = Number of Vertices (City Areas)
E = Number of Edges (Possible Roads)
Data Structure: Union-Find (Disjoint Set Union) with path compression and union by rank/size.

Step 1: Sorting Edges
- Purpose: Sort all E potential roads by their construction cost in ascending order.
- Algorithm Used: Standard Comparison Sort (e.g., MergeSort or HeapSort).
- Cost: E * O(log E)
- Total Cost: O(E log E)

Step 2: Initialize Union-Find
- Purpose: Create V disjoint sets, one for each area (vertex).
- Operation: V initialization operations.
- Total Cost: O(V)

Step 3: Edge Processing and Union-Find Operations (Main Loop)
- Purpose: Iterate through the sorted edges and add an edge to the MST if it does not form a cycle (checked by Union-Find).
- Operations: The loop runs E times, and each iteration performs two Find operations (check for cycle) and at most one Union operation (add edge).
- Cost per operation: The amortized time complexity for Find and Union operations with modern optimizations is nearly constant, denoted as O(alpha(V)), where alpha(V) is the inverse Ackermann function, which grows extremely slowly (always < 5 for practical inputs).
- Total Cost: E * O(alpha(V))

Overall Time Complexity:
The overall time is the sum of the three steps.
Total Time Complexity = O(E log E) + O(V) + O(E * alpha(V))

Since O(E log E) is typically much larger than the Union-Find cost, and V <= E in any connected graph:

Final Time Complexity = O(E log E)
`,
        complexity: 'O(E log E)'
    },
    {
        id: 'c6',
        title: 'Mall Parking Allocation',
        problem: 'Efficiently assign the closest available parking slot to an arriving vehicle and track occupancy.',
        icon: 'fa-parking', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c6',
        algo: 'Min-Heap + Hashing',
        diagram: `<img src="./dron_img/c6.png" style="max-width:100%; height:500px;">`,
        why: 'This uses a <strong>Min-Heap (Priority Queue)</strong> for instant O(\log n) retrieval of the closest (smallest slot number) free slot. The <strong>Hashing</strong> technique (Hash Map) provides O(1) average-case time complexity for tracking occupancy, which is crucial for fast lookup and release operations in a high-traffic system.',
        how: [
            'Initially, all free slot numbers are inserted into a Min-Heap.',
            'On vehicle arrival, the smallest available slot is popped from the heap (Min-Heap property).',
            'The slot is assigned, and the assignment is recorded in a Hash Map (Vehicle ID → Slot ID).',
            'On vehicle exit, the slot number is pushed back into the Min-Heap, restoring its availability.'
        ],
        complexityCode: `
Time Complexity Derivation (Min-Heap + Hashing):

Assumptions:
N = Total Number of Parking Slots
The system relies on a Min-Heap (Priority Queue) to store available slot IDs and a Hash Map (Hash Table) to track occupied slots.

Step 1: Vehicle Arrival (Assignment)
- Purpose: Assign the closest (lowest ID) available slot to the arriving vehicle.
- Operation: Requires extracting the minimum element (the lowest slot ID) from the Min-Heap.
- Cost per Extract Min: O(log N)
- Operation: Recording the assignment in the Hash Map (License Plate -> Slot ID).
- Cost per Hash Insert: O(1) (Amortized)
- Total Cost for Assignment: O(log N) + O(1) = O(log N)

Step 2: Vehicle Exit (Release)
- Purpose: Release the occupied slot and make it available again.
- Operation: Look up the slot ID in the Hash Map (O(1)) and remove the entry.
- Operation: Inserting the newly free slot ID back into the Min-Heap.
- Cost per Heap Insert: O(log N)
- Total Cost for Release: O(1) + O(log N) = O(log N)

Overall Time Complexity:
The complexity of the system is dominated by the logarithmic time required for Heap operations (insertion and deletion/extraction).

Final Time Complexity = O(log N) for both Assignment and Release operations.
`,
        complexity: 'O(log N)'
    },
    {
        id: 'c7',
        title: 'Streetlight Maintenance Scheduling',
        problem: 'Prioritize and efficiently route maintenance teams to repair faulty streetlights based on urgency.',
        icon: 'fa-lightbulb', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c7',
        algo: 'Priority Queue + BFS',
        diagram: `<img src="./dron_img/c7.png" style="max-width:100%; height:500px;">`,
        why: 'A <strong>Max-Heap (Priority Queue)</strong> implements a <strong>Greedy</strong> scheduling strategy by ensuring the highest urgency fault is addressed first. <strong>BFS (Breadth-First Search)</strong> is then used to find the shortest path (optimizing travel time) from the depot to the prioritized location, minimizing operational delays.',
        how: [
            'Fault reports are inserted into a Max-Heap based on a calculated priority score (importance, number of complaints).',
            'The most urgent fault is popped from the heap.',
            'BFS is run on the city\'s street graph from the maintenance team\'s current location to the fault location to find the quickest path.',
            'After repair, the team repeats the process by addressing the next highest priority fault.'
        ],
        complexityCode: `
Time Complexity Derivation (Max-Heap + BFS):

Assumptions:
F = Number of faulty lights (size of the heap/jobs)
V = Number of Vertices (Junctions) in the road network
E = Number of Edges (Roads) in the road network
Data Structure: Max-Heap (Priority Queue) for scheduling, Graph representation for road network.

Step 1: Fault Prioritization (Heap Operations)
- Purpose: Maintain the set of F faults and repeatedly extract the one with the highest urgency score.
- Operation: Involves F extractions from the Max-Heap.
- Cost per operation: O(log F)
- Total Cost for Heap Operations: F * O(log F) = O(F log F)

Step 2: Routing the Maintenance Team (Graph Search)
- Purpose: For each of the F prioritized faults, calculate the fastest route from the depot/team's current location to the fault location.
- Algorithm Used: Breadth-First Search (BFS) is used to find the shortest path in an unweighted graph, or can represent the cost of traversing the road network (V+E).
- Operation: BFS is run F separate times (once per job).
- Cost per BFS run: O(V + E)
- Total Cost for Routing: F * O(V + E)

Overall Time Complexity:
The overall time is the sum of the two sequential, independent processes.

Total Time Complexity = O(F log F) + O(F * (V + E))

Final Time Complexity = O(F log F + F(V + E))
`,
        complexity: 'O(F log F + F(V+E))'
    },
    {
        id: 'c8',
        title: 'Library Book Search System',
        problem: 'Enable fast searching and prefix matching for book titles in a large city library database.',
        icon: 'fa-book-open', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c8',
        algo: 'Trie + Binary Search',
        diagram: `<img src="./dron_img/c8.png" style="max-width:100%; height:500px;">`,
        why: 'The <strong>Trie</strong> (Prefix Tree) is the ideal data structure for auto-complete and prefix matching. It uses the <strong>Space and Time Trade-off</strong> principle to achieve search times that depend only on the length of the query string (O(L)), making it significantly faster than typical database lookups for this specific functionality.',
        how: [
            'All book titles are inserted into the Trie, with each node representing a letter.',
            'Searching for a prefix involves navigating the tree based on the input letters.',
            'Once the prefix node is reached, all strings in the subtree rooted at that node are collected as valid suggestions.',
            'Binary Search can be used as a secondary mechanism for fast lookup within sorted lists of books in specific categories.'
        ],
        complexityCode: `
Time Complexity Derivation (Trie / Prefix Tree):

Assumptions:
N = Total Number of books/words in the database
L = Length of the query string (the prefix)
M = Total length of all N words combined (Used for insertion cost)
Z = Total number of matching suggestions retrieved from the Trie
Data Structure: Trie (Prefix Tree).

Step 1: Trie Construction (Preprocessing)
- Purpose: Insert all N book titles into the Trie.
- Operation: Traversing and creating nodes for every character of every word.
- Cost: Proportional to the sum of the lengths of all words (M).
- Total Cost: O(M)

Step 2: Searching for a Prefix
- Purpose: Find the node corresponding to the end of the query prefix (L).
- Operation: Traverse the Trie starting from the root, moving down L levels (one level per character).
- Cost per traversal: O(L)

Step 3: Retrieving Suggestions
- Purpose: Collect all matching words (Z words) that exist in the subtree rooted at the prefix node found in Step 2.
- Operation: This involves a traversal (like DFS) from the prefix node to all its leaf nodes.
- Cost per retrieval: Proportional to the total number of characters in all Z suggested words. Let's simplify this retrieval time to be proportional to Z (the number of suggestions).
- Total Cost for retrieval: O(Z)

Overall Time Complexity for a Search Operation:
The search operation consists of the prefix traversal and the suggestion retrieval.

Total Search Time Complexity = (Step 2) + (Step 3)
Total Search Time Complexity = O(L) + O(Z) 

Final Time Complexity (Search): O(L + Z)
`,
        complexity: 'O(L + Z)'
    },
    
    {
        id: 'c11',
        title: 'Market Shop Rent Analysis (Monthly Changes)',
        problem: 'Quickly query the cumulative change in shop rents within any market segment following frequent monthly updates.',
        icon: 'fa-chart-line', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c11',
        algo: 'Fenwick Tree (Binary Indexed Tree)',
        diagram: `<img src="./dron_img/c11.png" style="max-width:100%; height:500px;">`,
        why: 'The <strong>Fenwick Tree</strong> (or Binary Indexed Tree) is highly specialized for fast <strong>Point Updates</strong> and <strong>Range Sum Queries</strong>. It utilizes <strong>Bit Manipulations</strong> and <strong>Pre-Computing</strong> to achieve O(\log n) time complexity for both operations, making it more space-efficient and often faster in practice for range sum queries than a full Segment Tree.',
        how: [
            'The tree is initialized based on the shop indices.',
            'For a rent change in a single shop (Point Update), the tree is updated by traversing up the indices, guided by the least significant bit, in O(log n) time.',
            'For a range query [i, j] (total rent change), the query is broken down into prefix sums: PrefixSum[j] - PrefixSum[i-1]. Prefix sums are computed by cleverly aggregating pre-computed segment sums, also in O(log n) time.'
        ],
        complexityCode: `
Time Complexity Derivation (Fenwick Tree / Binary Indexed Tree):

Assumptions:
N = Number of elements in the base array (Shops/Segments)
The Fenwick Tree is a data structure optimized for prefix sum calculations.

Step 1: Tree Construction (Preprocessing)
- Purpose: Initialize the Fenwick Tree with the initial rent values.
- Operation: This can be done by iteratively calling the single-element Update operation N times.
- Cost per Update: O(log N)
- Total Cost: N * O(log N) = O(N log N)
- *Note: Construction can also be done in O(N) using a specialized bottom-up approach, but the iterative update method is more common.*

Step 2: Single-Element Update (Rent Change)
- Purpose: Change the rent for a single shop and update the Fenwick Tree's prefix sums accordingly.
- Operation: The update path follows the binary representation of the index, specifically adding the new value to O(log N) nodes in the tree.
- Cost per update: O(log N)
- Total Cost: O(log N)

Step 3: Prefix Sum Query (Total Rent up to Shop i)
- Purpose: Calculate the cumulative rent from the start of the market up to a specific shop index i.
- Operation: The query path also follows the binary representation of the index, summing the values from O(log N) specific nodes.
- Cost per query: O(log N)

Step 4: Range Sum Query (Total Rent in a segment [i, j])
- Purpose: Calculate the total rent for a range of shops from index i to j.
- Operation: This is calculated by performing two prefix sum queries: Query(j) - Query(i-1).
- Cost per Range Query: O(log N) + O(log N) = O(log N)

Final Time Complexity:
The key dynamic operations (Update and Query) are logarithmic.

Final Time Complexity = O(log N) for both Update and Query operations.
`,
        complexity: 'O(log N)'
    },
    // New Case Study 9: Pharmacy Inventory Expiry Manager
    {
        id: 'c9',
        title: 'Pharmacy Inventory Expiry Manager',
        problem: 'Ensure medicines are sold based on the FIFO (First-In, First-Out) principle applied to expiry date, minimizing waste.',
        icon: 'fa-pills', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c9',
        algo: 'Min-Heap + Hash Map',
        diagram: `<img src="./dron_img/c9.png" style="max-width:100%; height:500px;">`,
        why: 'This combines the <strong>Greedy Technique</strong> with specialized data structures. The <strong>Min-Heap</strong> stores items prioritized by expiry date, guaranteeing O(log n) access to the soonest-expiring medicine. The <strong>Hash Map</strong> provides O(1) average-case lookup for checking stock quantities and managing different product types.',
        how: [
            'Medicines are inserted into a Min-Heap using a pair (expiry\_date, unique\_ID) as the key, ensuring the earliest expiry date is always at the root.',
            'A Hash Map tracks the total quantity available for each unique medicine ID.',
            'When a medicine is requested, the Min-Heap root provides the specific batch with the nearest expiry date for sale (Extract Min).',
            'When new stock arrives, it is inserted into the heap. The Hash Map quantity is updated accordingly.'
        ],
        complexityCode: `
Time Complexity Derivation (Min-Heap + Hash Map):

Assumptions:
N = Total number of unique batches/expiry dates in inventory (size of the Min-Heap).

Step 1: Selling/Removal (Extract Min)
- Purpose: Retrieve the batch with the earliest expiry date.
- Operation: Requires extracting the minimum element from the Min-Heap.
- Cost per operation: O(log N)
- Total Cost for Selling: O(log N)

Step 2: Receiving/Insertion (Insert)
- Purpose: Add a new batch of medicine to the inventory.
- Operation: Requires inserting a new element into the Min-Heap.
- Cost per operation: O(log N)
- Operation: Updating the Hash Map quantity (O(1) amortized).
- Total Cost for Receiving: O(log N) + O(1) = O(log N)

Overall Time Complexity:
The complexity of inventory management operations (sell/receive) is dominated by the Heap operations.

Final Time Complexity = O(log N) for core operations.
`,
        complexity: 'O(log N)'
    },
    // New Case Study 10: Mobile Tower Coverage Gap Finder
    {
        id: 'c10',
        title: 'Mobile Tower Coverage Gap Finder',
        problem: 'Analyze and dynamically locate areas within the city grid that lack sufficient mobile network coverage.',
        icon: 'fa-wifi', 
        repoLink:'https://github.com/Dron-cyber/DAA_CITY_PROJECT.github.io/tree/main/dron/c10',
        algo: 'BFS + Segment Tree (or similar 2D structure)',
        diagram: `<img src="./dron_img/c10.png" style="max-width:100%; height:500px;">`,
        why: 'This uses <strong>BFS</strong> to model signal propagation, treating tower coverage as a graph search problem to find all reachable (covered) cells (O(V+E)). Unvisited cells denote gaps. The secondary use of a <strong>Segment Tree</strong> (or a similar structure like a Quad Tree in 2D) allows for O(log N) aggregation of coverage strength across large zones.',
        how: [
            'The city is modeled as a grid of cells.',
            'Initiate a BFS simultaneously from all active mobile towers.',
            'The BFS propagates outward up to the maximum signal range, marking every reached cell as "covered" and recording its signal strength.',
            'After all BFS runs complete, any unvisited cells represent coverage gaps.',
            'A Segment Tree structure can be used over the grid to efficiently query the minimum signal strength within a large geographical area.'
        ],
        complexityCode: `
Time Complexity Derivation (BFS + 2D Structure):

Assumptions:
R = Rows, C = Columns (V = R * C total cells)
T = Number of Mobile Towers
The cost is dominated by the initial coverage mapping.

Step 1: Coverage Mapping (Multi-Source BFS)
- Purpose: Determine all cells covered by signal propagation from the T towers.
- Operation: A multi-source BFS is performed on the grid. Since each cell (V) and connection (E) is visited/checked at most once during the total propagation process.
- Cost per BFS: O(V + E) = O(R * C)
- Total Cost: O(R * C)

Step 2: Gap Query (Finding Unvisited Cells)
- Purpose: Iterate through the grid/array to identify cells not marked as covered.
- Operation: Linear scan of all V cells.
- Total Cost: O(V) = O(R * C)

Step 3 (Secondary): Range Query on Coverage Strength (Using 2D Segment Tree/Quad Tree)
- Purpose: If required, query the minimum signal strength over a large rectangle area.
- Cost: O(log R * log C) for a 2D Segment Tree or O(log N) for a Quad Tree on the grid.

Overall Time Complexity:
The primary task of gap detection is dominated by the graph traversal.

Final Time Complexity = O(R * C) for coverage mapping.
`,
        complexity: 'O(R * C)'
    }
];

// --- Card Generation and Modal Logic ---
const grid = document.getElementById('caseStudyGrid');
const modalOverlay = document.getElementById('modalOverlay');
const modalContent = document.getElementById('modalContent');

// 1. Function to create the initial card HTML 
function createCard(study) {
    const card = document.createElement('div');
    card.className = 'case-study-card';
    card.setAttribute('data-id', study.id);
    
    // GitHub link element for the small card
    const githubLinkCard = document.createElement('a');
    githubLinkCard.href = study.repoLink;
    githubLinkCard.className = 'github-link-card';
    githubLinkCard.target = '_blank';
    githubLinkCard.innerHTML = '<i class="fab fa-github"></i>';

    
    card.onclick = (e) => {
        // Prevent modal opening if the GitHub link was clicked
        if (e.target.closest('.github-link-card')) return;
        openModal(study.id);
    };

    card.innerHTML = `
        <div class="card-title">
            <i class="fas ${study.icon}"></i>
            <h3>${study.title}</h3>
        </div>
        <p>${study.problem}</p>
        <div class="algo-used">Algorithm: <strong>${study.algo}</strong></div>
    `;

    card.appendChild(githubLinkCard);
    return card;
}

// 2. Insert all cards into the grid on load
caseStudies.forEach(study => {
    grid.appendChild(createCard(study));
});

// 3. Function to open the modal and load content
function openModal(id) {
    const study = caseStudies.find(s => s.id === id);
    if (!study) return;

    // Remove strong tags from the 'how' list items for cleaner presentation
    const howList = study.how.map(item => `<li>${item.replace(/<strong[^>]*>|<\/strong>/g, '')}</li>`).join('');

    // Generate the full modal content structure
    modalContent.innerHTML = `
        <span class="close-btn" onclick="closeModal(event)">&times;</span>
        <h2>${study.title}</h2>
        <div class="algo-used" style="font-size:16px;">Algorithm: <strong>${study.algo}</strong></div>
        
        <h4>Problem Statement</h4>
        <p>${study.problem}</p>

        <h4>Why This Algorithm? (Design Rationale)</h4>
        <p>${study.why}</p>

        <h4>How It Works (Algorithm Flow)</h4>
        <ul>${howList}</ul>
        
        <h4 style="margin-top: 35px;">Algorithm Flow Diagram</h4>
        <div class="modal-diagram-space">
            ${study.diagram}
            <p>Diagram illustrating the operational flow of <strong>${study.algo}</strong>.</p>
        </div>

        <h4>Efficiency Calculation and Complexity (${study.complexity})</h4>
        <p>The calculation below provides the theoretical time complexity (Big O notation) for the core operation(s) of this algorithm, demonstrating its performance scalability:</p>
        <code>${study.complexityCode}</code>
        
        <a href="${study.repoLink}" target="_blank" class="github-btn-modal">
            <i class="fab fa-github"></i> View Code on GitHub
        </a>
    `;

    modalOverlay.style.display = 'flex';
    document.body.style.overflow = 'hidden'; 
}

// 4. Function to close the modal
function closeModal(event) {
    if (event.target.classList.contains('close-btn') || event.target.id === 'modalOverlay') {
        modalOverlay.style.display = 'none';
        document.body.style.overflow = 'auto'; 
    }
}
</script>
